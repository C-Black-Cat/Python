# 03-TCP客户端

### 1.TCP介绍

**TCP协议**：传输控制协议（`Transmission Control Protocol`）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 `IETF` 的 `RFC 793` 定义。

TCP通信需要通过：**数据连接**、**数据传送**、**终止连接**三个步骤。

TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似生活中的 "打电话"。

#### TCP特点

1. **面向连接**

   通信双方必须先建立连接才能进行数据的传输，**双方都必须为该连接分配必要的系统内核资源**，以管理连接的状态和连接上的传输。

   双方间的数据传输都可以通过这一个连接进行。

   完成数据交换后，双方必须断开此连接，以释放系统资源。

   这种连接是一对一的，`因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP`。

2. **可靠传输**

   - **TCP采用发送应答机制**

     TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文传输成功。

     > 例如：在使用迅雷下载电影时，除了有下载的流量，或多或少还会有一些上传的流量。其实这里上传的就是接收数据后的应答。一个几个G的电影是不可能一次性发送过来的，传输时会将这几个G的数据分成N多分小数据，因此也就会有N多次的应答。而且接收数据时是使用内存来临时存储要接收的数据，若是数据很大且一次性接收，那么内存空间可能不够，无法完成接收。

   - **超时重传**

     发送端发送一个报文段之后就启动定时器，如果在定时时间内没有接收到应答就重新发送这个报文段。

     TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失，并且发送端将会进行数据重传。

   - **错误校验**

     TCP用一个校验和函数来检测数据是否有错误；在发送和接收时都要计算校验和。

   - **流量控制和阻塞管理**

     流量控制用来避免主机发送得过快而使得接收方来不及完全收下。

#### TCP于UDP的不同点

- 面向连接（确认有创建三次握手，连接已创建才进行传输）

- 重发丢失的数据包
- 舍弃重复的数据包
- 无差别的数据传输
- 阻塞/流量控制

#### UDP通信模型

UDP通信模型中，在通信开始之前，不需要建立相关的连接，只需要发送数据即可，类似于生活中的 "写信"。

![01-udp发送数据demo-120220711-215603](D:\Typora\my_file\图片\01-udp发送数据demo-120220711-215603.png)

#### TCP通信模型

TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中的 "打电话"。

![Screenshot_20220714_125050](D:\Typora\my_file\图片\Screenshot_20220714_125050.jpg)

### 2.TCP客户端

> 笑话：一个顾客去饭店吃饭，这个顾客要点菜，就问服务员咱们饭店有客户端吗，然后这个服务员非常客气地说道：先生，我们饭店不用客户端，我们直接送到您的餐桌上。

所谓服务端，就是提供服务的一方；而客户端，就是需要被服务的一方。

#### TCP客户端构建流程

TCP客户端比服务器端简单很多，如果说服务器端是需要自己买手机、插手机卡、设置铃声等待别人打电话的流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少得多。

```python
from socket import * 

# 1.创建套接字
tcp_client_socket = socket(AF_INET, SOCK_STREAM)

# 2.目的信息
server_ip = input("请输入服务器IP：")
server_port = int(input("请输入服务器port："))

# 3.链接服务器
tcp_client_socket.connect((server_ip, server_port))

# 4.显示用户输入数据
send_data = input("请输入要发送的数据：")
tcp_client_socket.send(send_data.encode('gbk'))

# 5.接收对方发送过来的数据，最大接收1024个字节
recvData = tcp_client_socket.recv(1024)
print("接收到的数据为：", recvData.decode('gbk'))

# 6.关闭套接字
tcp_client_socket.close()
```

> TCP客户端一般不绑定port。

> **UDP和TCP发送数据的区别：**
>
> - UDP中发送数据的函数是：`sendto()`
>
> - TCP中发送数据的函数是：`send()`
>
> 怎么理解和记忆这两个函数：
>
> 1. UDP中的 `sendto()` 意味 `发送...到...`。函数的参数有：发送的数据 和 `(IP, port)`。从函数名的意思可以理解为不仅要输入信息，还要输入接收方的IP地址和端口号。
>
> 2. TCP中的 `send()` 意味 `发送`。函数的参数只有要发送的数据。TCP通信时，要使用 `connect()` 链接服务器，因此使用 `send()` 时仅需要填入要发送的数据，不需要再填写地址信息。
>
> **UDP和TCP接收数据的区别：**
>
> - UDP中接收数据的函数是：`recvfrom()`
> - TCP中接收数据的函数是：`recv()`
>
> 理解和记忆：
>
> 1. UDP中的 `recvfrom()` 意味着 `接收...从...`。函数的返回值为一个包含接收消息和地址消息的元组：`(recv_msg, (IP, port))`。UDP在接收数据之前并不知道发送方的IP地址和port，因此 `recvfrom()` 的返回值之中有发送方的地址消息也是可以理解的。从函数名的含义可以得知返回值中含有发送方的地址消息。
> 2. TCP中的 `recv()` 意味着 `接收...`。函数的返回值只有接收的消息。TCP客户端在收发数据之前都要链接服务器，已经知晓了服务器的地址；TCP服务器的 `accept()` 函数会返回一个包含新链接客户端的地址信息的元组。这些都可以解释为什么 `recv()` 不需要返回地址信息。
>
> **补充**：
>
> TCP在通信之前都需要建立连接，这个连接的过程双方会交换地址信息，因此之后收发数据时，双方都已经知道对方的地址信息，也就不需要再输入或返回地址信息了。所以TCP的 `send()`和 `recv()` 方法都不需要地址信息。

**注意：**网络调试助手要选择：`TCP服务器`

**代码**

```python
from socket import *


def main():
    # 1. 创建套接字
    tcp_client_socket = socket(AF_INET, SOCK_STREAM)
    # 2. 目的消息
    server_ip = input("请输入服务器ip:")
    server_port = int(input("请输入服务器端口:"))

    # 3. 链接服务器
    tcp_client_socket.connect((server_ip, server_port))

    # 4. 显示用户输入数据
    send_data = input("请输入要发送的数据:")
    tcp_client_socket.send(send_data.encode('utf-8'))

    # 5. 接收对方发送过来的数据
    recv_data = tcp_client_socket.recv(1024)
    print("接收到的数据为:", recv_data.decode("utf-8"))

    # 6. 关闭套接字
    tcp_client_socket.close()

if __name__ == "__main__":
    main()
```

**结果**

![image-20220714162007824](D:\Typora\my_file\图片\image-20220714162007824.png)
